package com.cenit.battleship.model;

import com.cenit.battleship.model.enums.ShipType;
import com.cenit.battleship.model.enums.Direction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Representa un barco en el juego de batalla naval con tracking de da√±o por segmento
 * @author Usuario
 */
public class Ship {
    
    private final ShipType type;
    private final List<Cell> positions;
    private int impactsReceived;
    private List<Coordinate> coordinates;
    private Direction direction;
    
    // Array para trackear qu√© segmentos est√°n da√±ados
    private List<Boolean> segmentDamage;
    
    public Ship(ShipType type) {
        this.type = type;
        this.positions = new ArrayList<>();
        this.coordinates = new ArrayList<>();
        this.impactsReceived = 0;
        this.direction = Direction.HORIZONTAL;
        this.segmentDamage = new ArrayList<>();
    }
    
    // ========== POSICIONAMIENTO ==========
    
    /**
     * Establece la posici√≥n del barco y inicializa el tracking de da√±o
     */
    public void setPosition(List<Coordinate> coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("La lista de coordenadas no puede ser nula");
        }
        
        if (coordinates.size() != type.getSize()) {
            throw new IllegalArgumentException(
                "El barco " + type.getName() + " requiere " + type.getSize() + 
                " coordenadas, pero se proporcionaron " + coordinates.size()
            );
        }
        
        // Validar que las coordenadas sean consecutivas
        if (!areCoordinatesConsecutive(coordinates)) {
            throw new IllegalArgumentException("Las coordenadas del barco deben ser consecutivas");
        }
        
        this.coordinates = new ArrayList<>(coordinates);
        initializeSegmentDamage();
        determineDirection(coordinates);
        
        System.out.println("üìç Barco " + type.getName() + " posicionado en " + 
                          coordinates.get(0).aNotacion() + " a " + 
                          coordinates.get(coordinates.size() - 1).aNotacion() +
                          " (" + direction + ")");
    }
    
    /**
     * Inicializa el array de da√±o por segmento (todos false inicialmente)
     */
    private void initializeSegmentDamage() {
        segmentDamage = new ArrayList<>();
        for (int i = 0; i < coordinates.size(); i++) {
            segmentDamage.add(false);
        }
    }
    
    /**
     * Determina la direcci√≥n del barco basado en sus coordenadas
     */
    private void determineDirection(List<Coordinate> coordinates) {
        if (coordinates.size() <= 1) {
            this.direction = Direction.HORIZONTAL;
            return;
        }
        
        Coordinate first = coordinates.get(0);
        Coordinate second = coordinates.get(1);
        
        if (first.getX() == second.getX()) {
            this.direction = Direction.VERTICAL;
        } else if (first.getY() == second.getY()) {
            this.direction = Direction.HORIZONTAL;
        } else {
            throw new IllegalArgumentException("El barco debe estar en l√≠nea recta horizontal o vertical");
        }
    }
    
    /**
     * Verifica si las coordenadas son consecutivas
     */
    private boolean areCoordinatesConsecutive(List<Coordinate> coordinates) {
        if (coordinates.size() <= 1) {
            return true;
        }
        
        boolean isHorizontal = true;
        boolean isVertical = true;
        
        int baseX = coordinates.get(0).getX();
        int baseY = coordinates.get(0).getY();
        
        for (int i = 1; i < coordinates.size(); i++) {
            Coordinate current = coordinates.get(i);
            
            // Para ser horizontal, todas las X deben ser iguales y las Y consecutivas
            if (isHorizontal) {
                if (current.getX() != baseX || current.getY() != baseY + i) {
                    isHorizontal = false;
                }
            }
            
            // Para ser vertical, todas las Y deben ser iguales y las X consecutivas
            if (isVertical) {
                if (current.getY() != baseY || current.getX() != baseX + i) {
                    isVertical = false;
                }
            }
            
            if (!isHorizontal && !isVertical) {
                return false;
            }
        }
        
        return true;
    }
    
    // ========== SISTEMA DE DA√ëO Y REPARACI√ìN ==========
    
    /**
     * Registra un impacto en una coordenada espec√≠fica
     * @param coord Coordenada impactada
     * @return true si el impacto fue registrado exitosamente
     */
    public boolean registerHitAtCoordinate(Coordinate coord) {
        for (int i = 0; i < coordinates.size(); i++) {
            if (coordinates.get(i).equals(coord)) {
                if (!segmentDamage.get(i)) {
                    segmentDamage.set(i, true);
                    impactsReceived++;
                    
                    System.out.println("üí• Impacto en " + type.getName() + " en " + 
                                     coord.aNotacion() + " (" + (impactsReceived) + "/" + type.getSize() + ")");
                    
                    if (isSunk()) {
                        System.out.println("üíÄ " + type.getName() + " HUNDIDO!");
                    }
                    return true;
                } else {
                    System.out.println("‚ö†Ô∏è Impacto repetido en " + type.getName() + " en " + coord.aNotacion());
                    return false;
                }
            }
        }
        return false;
    }
    
    /**
     * Registra un impacto general (sin coordenada espec√≠fica)
     */
    public void recordImpact() {
        if (!isSunk()) {
            // Encontrar el primer segmento no da√±ado
            for (int i = 0; i < segmentDamage.size(); i++) {
                if (!segmentDamage.get(i)) {
                    segmentDamage.set(i, true);
                    impactsReceived++;
                    
                    System.out.println("üí• Impacto en " + type.getName() + 
                                     " (" + impactsReceived + "/" + type.getSize() + ")");
                    
                    if (isSunk()) {
                        System.out.println("üíÄ " + type.getName() + " HUNDIDO!");
                    }
                    return;
                }
            }
        }
    }
    
    /**
     * Repara una parte espec√≠fica del barco en la coordenada dada
     * @param position Coordenada a reparar
     * @return true si la reparaci√≥n fue exitosa
     */
    public boolean repairAtCoordinate(Coordinate position) {
        if (!isPlaced()) {
            System.err.println("‚ùå No se puede reparar: el barco no est√° colocado");
            return false;
        }
        
        if (!occupiesCoordinate(position)) {
            System.err.println("‚ùå No se puede reparar: la coordenada " + position.aNotacion() + 
                             " no pertenece a este barco");
            return false;
        }
        
        // Buscar la posici√≥n en las coordenadas del barco
        for (int i = 0; i < coordinates.size(); i++) {
            if (coordinates.get(i).equals(position)) {
                // Verificar si esta parte est√° da√±ada
                if (segmentDamage.get(i)) {
                    // Reparar este segmento
                    segmentDamage.set(i, false);
                    impactsReceived--;
                    
                    System.out.println("üîß Parte reparada: " + type.getName() + " en " + 
                                     position.aNotacion() + " | Impactos restantes: " + 
                                     impactsReceived + "/" + type.getSize());
                    return true;
                } else {
                    System.out.println("‚ÑπÔ∏è La parte en " + position.aNotacion() + " ya est√° intacta");
                    return false;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Repara completamente el barco (todas las partes)
     * @return true si se repar√≥ al menos una parte
     */
    public boolean fullRepair() {
        if (impactsReceived == 0) {
            System.out.println("‚ÑπÔ∏è " + type.getName() + " ya est√° completamente reparado");
            return false;
        }
        
        int repairedCount = impactsReceived;
        impactsReceived = 0;
        
        // Resetear todos los segmentos
        for (int i = 0; i < segmentDamage.size(); i++) {
            segmentDamage.set(i, false);
        }
        
        System.out.println("üîß " + type.getName() + " completamente reparado: " + 
                         repairedCount + " partes restauradas");
        return true;
    }
    
    /**
     * Verifica si una parte espec√≠fica del barco est√° da√±ada
     * @param position Coordenada a verificar
     * @return true si esa parte est√° da√±ada
     */
    public boolean isPartDamaged(Coordinate position) {
        if (!occupiesCoordinate(position)) {
            return false;
        }
        
        for (int i = 0; i < coordinates.size(); i++) {
            if (coordinates.get(i).equals(position)) {
                return segmentDamage.get(i);
            }
        }
        return false;
    }
    
    /**
     * Verifica si el barco puede ser reparado (tiene partes da√±adas)
     * @return true si tiene al menos una parte da√±ada
     */
    public boolean canBeRepaired() {
        return impactsReceived > 0 && !isSunk();
    }
    
    // ========== M√âTODOS DE CONSULTA ==========
    
    /**
     * Verifica si el barco est√° hundido
     */
    public boolean isSunk() {
        return impactsReceived >= type.getSize();
    }
    
    /**
     * Verifica si el barco est√° colocado
     */
    public boolean isPlaced() {
        return !positions.isEmpty() || !coordinates.isEmpty();
    }
    
    /**
     * Verifica si el barco ocupa una coordenada espec√≠fica
     */
    public boolean occupiesCoordinate(Coordinate coord) {
        return coordinates.contains(coord);
    }
    
    /**
     * Obtiene el porcentaje de da√±o del barco
     */
    public double getDamagePercentage() {
        return (double) impactsReceived / type.getSize();
    }
    
    /**
     * Obtiene el porcentaje de integridad del barco
     */
    public double getIntegrityPercentage() {
        return 1.0 - getDamagePercentage();
    }
    
    /**
     * Obtiene la cantidad de partes reparables (da√±adas)
     */
    public int getRepairablePartsCount() {
        return impactsReceived;
    }
    
    /**
     * Obtiene la cantidad de partes intactas
     */
    public int getIntactPartsCount() {
        return type.getSize() - impactsReceived;
    }
    
    /**
     * Obtiene las coordenadas de las partes da√±adas
     */
    public List<Coordinate> getDamagedCoordinates() {
        List<Coordinate> damaged = new ArrayList<>();
        for (int i = 0; i < coordinates.size(); i++) {
            if (segmentDamage.get(i)) {
                damaged.add(coordinates.get(i));
            }
        }
        return Collections.unmodifiableList(damaged);
    }
    
    /**
     * Obtiene las coordenadas de las partes intactas
     */
    public List<Coordinate> getIntactCoordinates() {
        List<Coordinate> intact = new ArrayList<>();
        for (int i = 0; i < coordinates.size(); i++) {
            if (!segmentDamage.get(i)) {
                intact.add(coordinates.get(i));
            }
        }
        return Collections.unmodifiableList(intact);
    }
    
    /**
     * Obtiene el estado visual de cada segmento del barco
     */
    public String[] getVisualState() {
        String[] visual = new String[type.getSize()];
        for (int i = 0; i < type.getSize(); i++) {
            if (i < segmentDamage.size() && segmentDamage.get(i)) {
                visual[i] = "üí•"; // Segmento impactado
            } else {
                visual[i] = "üö¢"; // Segmento intacto
            }
        }
        return visual;
    }
    
    /**
     * Obtiene informaci√≥n detallada del estado del barco
     */
    public String getDamageStatus() {
        StringBuilder sb = new StringBuilder();
        sb.append(type.getName()).append(": ");
        
        for (int i = 0; i < type.getSize(); i++) {
            if (i < segmentDamage.size() && segmentDamage.get(i)) {
                sb.append("üí•");
            } else {
                sb.append("üö¢");
            }
        }
        
        sb.append(" (").append(impactsReceived).append("/").append(type.getSize()).append(")");
        sb.append(" | Integridad: ").append(String.format("%.0f", getIntegrityPercentage() * 100)).append("%");
        
        return sb.toString();
    }
    
    // ========== M√âTODOS DEL SISTEMA ORIGINAL ==========
    
    /**
     * Agrega una celda a la posici√≥n del barco (m√©todo original)
     */
    public void addPosition(Cell cell) {
        if (positions.size() >= type.getSize()) {
            throw new IllegalStateException("El barco ya tiene todas sus posiciones");
        }
        positions.add(cell);
        cell.setShip(this);
    }
    
    /**
     * Obtiene la coordenada de inicio del barco
     */
    public Coordinate getStartCoordinate() {
        if (coordinates.isEmpty()) {
            return null;
        }
        return coordinates.get(0);
    }
    
    /**
     * Obtiene la coordenada final del barco
     */
    public Coordinate getEndCoordinate() {
        if (coordinates.isEmpty()) {
            return null;
        }
        return coordinates.get(coordinates.size() - 1);
    }
    
    // ========== GETTERS ==========
    
    public ShipType getType() { 
        return type; 
    }
    
    public int getImpactsReceived() { 
        return impactsReceived; 
    }
    
    public Direction getDirection() { 
        return direction; 
    }
    
    public List<Coordinate> getCoordinates() {
        return Collections.unmodifiableList(coordinates);
    }
    
    public List<Cell> getPositions() {
        return Collections.unmodifiableList(positions);
    }
    
    public int getSize() {
        return type.getSize();
    }
    
    public String getName() {
        return type.getName();
    }
    
    // ========== RESET ==========
    
    /**
     * Reinicia el barco a su estado inicial
     */
    public void reset() {
        for (Cell cell : positions) {
            cell.reset();
        }
        positions.clear();
        coordinates.clear();
        impactsReceived = 0;
        direction = Direction.HORIZONTAL;
        segmentDamage.clear();
    }
    
    // ========== TO STRING ==========
    
    @Override
    public String toString() {
        return String.format("%s [Tama√±o: %d, Hundido: %s, Da√±o: %.0f%%, Direcci√≥n: %s]",
            type.getName(), type.getSize(), isSunk() ? "S√≠" : "No", 
            getDamagePercentage() * 100, direction);
    }
    
    /**
     * Obtiene informaci√≥n detallada del barco
     */
    public String getDetailedInfo() {
        StringBuilder sb = new StringBuilder();
        sb.append("Barco: ").append(type.getName()).append("\n");
        sb.append("Tama√±o: ").append(type.getSize()).append("\n");
        
        if (!coordinates.isEmpty()) {
            sb.append("Posici√≥n: ").append(getStartCoordinate().aNotacion())
              .append(" a ").append(getEndCoordinate().aNotacion())
              .append(" (").append(direction).append(")\n");
        } else {
            sb.append("Posici√≥n: No colocada\n");
        }
        
        sb.append("Estado: ");
        if (isSunk()) {
            sb.append("üíÄ HUNDIDO");
        } else {
            sb.append(String.format("%.0f%% da√±o", getDamagePercentage() * 100));
            sb.append(" - ").append(getIntactPartsCount())
              .append("/").append(type.getSize()).append(" intactos");
        }
        
        sb.append("\nSegmentos: ").append(getDamageStatus());
        
        return sb.toString();
    }
}
